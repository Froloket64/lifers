//! Automata engine components

use crate::grid_map;

// TODO:
// - Allow multiple `DataFn`s in `Automaton`

pub type Grid<T> = Vec<Vec<T>>;
pub type StepFn<S, D> = fn((usize, usize), S, &D) -> S;
pub type DataFn<S, D> = fn((usize, usize), &S, &Grid<S>) -> D;

#[derive(Debug, PartialEq)]
pub enum ExecutionState {
    Finished,
    Remaining(u32),
    Infinite,
}

/// The main struct that contains the state of an automaton.
///
/// It's recommended to use [`Automaton::build()`] for easier creation process.
pub struct Automaton<S, D = ()> {
    pub cells: Grid<S>,
    cells_data: Grid<D>,
    generations_left: Option<u32>,
    step_fn: StepFn<S, D>,
    // data_fns: Vec<DataFn<S, D>>,
    data_fn: Option<DataFn<S, D>>,
}

impl<S, D> Automaton<S, D> {
    /// Returns a builder to help construct an automaton.
    pub fn build(size: (usize, usize)) -> AutomatonBuilder<S, D> {
        AutomatonBuilder {
            cells: vec![],
            size,
            ..Default::default()
        }
    }

    /// Computes the next generation.
    pub fn step(&mut self) -> ExecutionState {
        // Get additional data for each cell
        self.data_fn.map(|f| {
            self.cells_data = grid_map!(self.cells.iter(), f, &self.cells).collect();
        });

        // Compute the next state for each cell
        let cells = std::mem::take(&mut self.cells);
        let next_cells = grid_map!(cells.into_iter(), |(x, y), state| (self.step_fn)(
            (x, y),
            state,
            &self.cells_data[y][x]
        ))
        .collect();

        self.cells = next_cells;

        // ~HACK:
        if let Some(ref mut x) = self.generations_left {
            *x -= 1;

            if *x == 0 {
                ExecutionState::Finished
            } else {
                ExecutionState::Remaining(*x)
            }
        } else {
            ExecutionState::Infinite
        }
    }
}

/// A helper struct to create an [`Automaton`].
// ~TODO: Add support for multiple `DataFn`s
pub struct AutomatonBuilder<S, D = ()> {
    cells: Vec<Vec<S>>,
    size: (usize, usize),
    generations_n: Option<u32>,
    // data_fns: Vec<DataFn<T, D>>,
    data_fn: Option<DataFn<S, D>>,
}

impl<S, D> Default for AutomatonBuilder<S, D> {
    fn default() -> Self {
        Self {
            cells: vec![],
            size: (0, 0),
            // data_fns: vec![],
            data_fn: None,
            generations_n: None,
        }
    }
}

impl<S, D> AutomatonBuilder<S, D> {
    /// Initializes every cell with state, generated by a function.
    /// `S` is used as the cells' state type further.
    ///
    /// **Note:** This function has to be run for proper behavior.
    // TODO: Figure out if `Fn` is suitable here
    pub fn init<F>(mut self, f: F) -> Self
    where
        F: Fn((usize, usize)) -> S,
    {
        let cells = (0_usize..self.size.1)
            .map(|y| (0_usize..self.size.0).map(|x| f((x, y))).collect())
            .collect();

        self.cells = cells;

        self
    }

    /// Sets a function to be applied to each cell before computing each generation.
    ///
    /// Collected data is passed to the step function (see [`AutomatonBuilder::run()`]).
    pub fn map(mut self, f: DataFn<S, D>) -> Self {
        // self.data_fns.push(f);
        self.data_fn = Some(f);

        self
    }

    /// Sets the number of generations to be generated. If this function isn't
    /// called, no limit it set.
    pub fn generations(mut self, n: u32) -> Self {
        self.generations_n = Some(n);

        self
    }

    /// Creates an [`Automaton`] with current parameters.
    ///
    /// The passed function ("step function") is called for every cell to
    /// compute the next state for each new generation.
    pub fn run(self, f: StepFn<S, D>) -> Automaton<S, D> {
        Automaton {
            cells: self.cells,
            cells_data: vec![],
            generations_left: self.generations_n.map(|x| x + 1),
            step_fn: f,
            // data_fns: self.data_fns
            data_fn: self.data_fn,
            // data_fn: self.data_fn.or(Some(|_, _, _| ())),
        }
    }
}

pub fn iter_grid<T>(grid: &[Vec<T>]) -> impl Iterator<Item = (usize, usize, &T)> {
    grid.iter()
        .enumerate()
        .flat_map(|(y, xs)| xs.iter().enumerate().map(move |(x, val)| (x, y, val)))
}

/// Counts the number of neighbors a cell has.
///
/// Extracts information on whether a cell is alive using an `extractor` function.
pub fn count_neighbors<S, F>(
    grid: &Grid<S>,
    pos: (usize, usize),
    radius: u32,
    extractor: F,
) -> usize
where
    F: Fn(&S) -> bool,
{
    let radius = radius as isize;

    (-radius..=radius)
        .flat_map(|x| {
            (-radius..=radius)
                .map(move |y| (pos.0.wrapping_add_signed(x), pos.1.wrapping_add_signed(y)))
        })
        .map(|(x, y)| {
            x < grid[1].len()
                && y < grid.len()
                && !(x == pos.0 && y == pos.1)
                && extractor(&grid[y][x])
        })
        .map(|b| b as usize)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::Automaton;

    #[test]
    fn builder() {
        let grid_size = (10, 10);

        // TODO: Allow inference
        let _game: Automaton<bool, ()> = Automaton::build(grid_size)
            .init(|(x, y)| x > y)
            .generations(5)
            .run(|(_x, _y), state, _| state);
    }
}
